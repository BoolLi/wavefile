<!DOCTYPE html>
<html lang="en">
<head>
  <title>WaveFile Gem</title>
  <meta charset="utf-8">
  <link href='http://fonts.googleapis.com/css?family=Lato:100,400' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Mono">
  <link rel="stylesheet" type="text/css" href="wavefile.css">
</head>
<body>
<div id="header">
  <div class="container">
  <h1><a href="/wavefile">WaveFile Gem</a></h1>
  <p id="tagline">Read and write *.wav sound files in pure Ruby.</p>
  <ul id="navigation">
    <li><a href="examples.html">Examples</a>&nbsp;&ndash;&nbsp;</li>
    <li><a href="documentation.html">Documentation</a>&nbsp;&ndash;&nbsp;</li>
    <li><a href="how_wave_files_work.html">How Wave Files Work</a></li>
  </ul>
  </div>
</div>
<div class="container">
  <h2>Reading a Wave File With a Block (Automatic File Closing Edition)</h2>

<p>The example below shows the preferred way of reading an entire wave file:</p>

<pre><code>require 'wavefile'
include WaveFile 

SAMPLE_FRAMES_PER_BUFFER = 4096

Reader.new("my_file.wav").each_buffer(SAMPLE_FRAMES_PER_BUFFER) do |buffer|
  puts "Read #{buffer.samples.length} samples."
end
</code></pre>

<p>First construct a <code>Reader</code> object, then call <code>each_buffer()</code> on it. Successive sample buffers will be read from the file and passed to the given block, until all sample data in the file has been read. Finally, the <code>Reader</code> will automatically be closed. (Note that this is essentially the same as how <code>IO.open</code> works if you pass it a block).</p>

<p>Note that when calling <code>each_buffer()</code> (and <code>read()</code>), the number you pass indicates the number of samples to read for <strong><em>each channel</em></strong>. That is, if you call <code>each_buffer(1024)</code> on a stereo/16-bit file, then the returned buffer will contain 1024 samples for the left channel, and 1024 samples for the right channel.</p>

<h2>Reading a Wave File (Manual File Closing Edition)</h2>

<p>Alternately, you can manually call <code>read()</code> to control exactly how much of the file to read. When doing this, make sure to close the <code>Reader</code> when you're done.</p>

<pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

reader = Reader.new("my_file.wav")
begin
  while true do
    buffer = reader.read(SAMPLES_PER_BUFFER)
    puts "Read #{buffer.samples.length} samples."
  end
rescue EOFError
  reader.close()
end
</code></pre>

<h2>Reading a Wave File Into an Arbitrary Format</h2>

<p>It's easy to read sample data out of a file in whatever format you need, regardless of what format is used inside the file. For example, suppose that <code>my_file.wav</code> is stereo/16-bit, but you need mono normalized floating point samples. No problem, as shown below.</p>

<pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

# Samples will be read as monophonic floating point,
# regardless of the actual sample format on disk
format = Format.new(:mono, :float, 44100)
reader = Reader.new("my_file.wav", format).each_buffer(SAMPLES_PER_BUFFER) do |buffer|
  puts "Read #{buffer.samples.length} samples."
end
</code></pre>

<h2>Getting Metadata About a Wave File</h2>

<pre><code>require 'wavefile'
include WaveFile

info = Reader.info("my_file.wav")
puts "  Audio Format:        #{info.audio_format}"
puts "  Channels:            #{info.channels}"
puts "  Bits per sample:     #{info.bits_per_sample}"
puts "  Samples per second:  #{info.sample_rate}"
puts "  Bytes per second:    #{info.byte_rate}"
puts "  Block align:         #{info.block_align}"
puts "  Sample frame count:  #{info.sample_frame_count}"

duration = info.duration
formatted_duration = duration.hours.to_s.rjust(2, "0") &lt;&lt; ":" &lt;&lt;
                     duration.minutes.to_s.rjust(2, "0") &lt;&lt; ":" &lt;&lt;
                     duration.seconds.to_s.rjust(2, "0") &lt;&lt; ":" &lt;&lt;
                     duration.milliseconds.to_s.rjust(3, "0")
puts "  Play time:           #{formatted_duration}"
</code></pre>

<h2>Writing a Wave File</h2>

<p>The <code>Writer</code> object is used to write data to a wave file. The example below shows how to write a basic square wave to a file.</p>

<pre><code>require 'wavefile'
include WaveFile

format = Format.new(:mono, :pcm_16, 44100)
writer = Writer.new("my_file.wav", format)

# Write a 1 second long 440Hz square wave
cycle = ([0.5] * 50) + ([-0.5] * 50)
buffer = Buffer.new(cycle, Format.new(:mono, :float, 44100))
220.times do
  writer.write(buffer)
end

writer.close()
</code></pre>

<h2>Copying a Wave File to Different Format</h2>

<p>In this example, the sample data in the file <code>original.wav</code> will be written to <code>copy.wav</code> as stereo/16-bit with a 44,100Hz sample rate, regardless of what format the sample data in <code>original.wav</code> is stored in.</p>

<p>This example also shows that you can also pass a block to <code>Writer.new()</code>, and the <code>Writer</code> will automatically be closed when the block exits.</p>

<pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

Writer.new("copy.wav", Format.new(:stereo, :pcm_16, 44100) do |writer|
  Reader.new("original.wav").each_buffer(SAMPLES_PER_BUFFER) do |buffer|
    writer.write(buffer)
  end
end
</code></pre>

<h2>Appending Wave Files</h2>

<pre><code>require 'wavefile'
include WaveFile

FILES_TO_APPEND = ["file1.wav", "file2.wav", "file3.wav"]
SAMPLES_PER_BUFFER = 4096

Writer.new("append.wav", Format.new(:stereo, :pcm_16, 44100) do |writer|
  FILES_TO_APPEND.each do |file_name|
    Reader.new(file_name).each_buffer(SAMPLES_PER_BUFFER) do |buffer|
      writer.write(buffer)
    end
  end
end
</code></pre>
  <p>Copyright &copy; <a href="http://www.joelstrait.com">Joel Strait</a> 2009-13.</p>
</div>
</body>
</html>
