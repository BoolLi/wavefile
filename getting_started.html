<!DOCTYPE html>
<html lang="en">
<head>
  <title>WaveFile Gem</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Playfair+Display:400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Mono">
  <link rel="stylesheet" type="text/css" href="wavefile.css">
</head>
<body>
<div id="header">
  <h1><a href="http://wavefilegem.com/">WaveFile Gem</a></h1>
  <ul id="navigation">
    <li><a href="getting_started.html">Getting Started</a></li>
    <li><a href="documentation.html">Documentation</a></li>
  </ul>
</div>
<div class="section">
  <h2>First Steps</h2>
  <p>First, <a href="http://wavefilegem.com#installation">install the WaveFile gem</a>.</p>
  <p>Next, if you're just getting started with audio programming, you might want to read up on some of the basics of digital audio first. Check out <a href="http://www.joelstrait.com/blog/2009/10/12/a_digital_audio_primer">this blog post</a> for an introduction.</p></p>
</div>
<div class="section bg-white">
  <h2>Basic Concepts</h2>
  <p>The WaveFile gem lets you both read and write wave files. Reading is done using the <code>Reader</code> class, and writing is done using the <code>Writer</code> class.</p>
  <p>The <code>Buffer</code> class represents a collection of samples in a given sample format (e.g. stereo 16-bit PCM samples at a 44,100Hz sample rate). When samples are read using <code>Reader</code> they are returned in <code>Buffer</code> instances. Samples to be written are given to <code>Writer</code> wrapped in <code>Buffer</code> instances as well.</p>
  <p>A <code>Buffer</code> consists of two parts: a Ruby array of samples, and a <code>Format</code> instance that describes what sample format. For example, the sample array in a <code>Buffer</code> read out of a mono 8-bit PCM file (in which each sample is an integer between 0 and 255) might look like this:</p>
  <pre><code>[45, 192, 13, 231, 201, 101, 15, ...etc...]</code></pre>
  <p>When there is more than one channel, each sample frame will be represent by a sub array. For example, a set of stereo floating point samples (in which each sample is between -1.0 and 1.0) might look like this:</p>
  <pre><code>[[-0.2, 0.4], [0.3, 0.9], [-0.4, -0.8], [0.9, -0.2], [-0.3, 0.4], ...etc...]</code></pre>
  <p>If writing a program that creates sound, you would generate an array like this with the sample data, then wrap it in a <code>Buffer</code>, and then use <code>Writer</code> to write the samples in the <code>Buffer</code> to disk.</p>
  <p><code>Buffer</code>s have the ability to convert their samples to a different format. This means that you can read samples from a file in a different format than what is actually in the file (e.g. read a file with 8-bit samples and get 16-bit samples back). You can also do the same with <code>Writer</code> - for example, generate floating point samples between -1.0 and 1.0, and transparently write them to a file as PCM samples.</p>
</div>
<div class="section">
  <h2>Creating a New Wave File</h2>
  <p>Let's write a simple tone to a wave file. A <a href="">square wave</a> is about the simplest way to create a sound, so let's do that. A square wave consists a some repeated samples, followed by the same number of repeated samples at the opposite amplitude. For example:</p>
  <pre><code>[0.3, 0.3, 0.3, 0.3, -0.3, -0.3, -0.3, -0.3,  ...and repeated...]</code></pre>
  <p>So, we'll write some code to generate these samples, and then wrap them in a <code>Buffer</code>, and then write these buffers to a file using <code>Writer</code>.</p>
  <p>The samples we'll generate will be in float format, which means they should be between -1.0 and 1.0. The larger each sample value, the louder it will sound (i.e. 0.5 will sound louder than 0.3). The faster that we alternate between the positive and negative samples, the higher the frequency of the tone (i.e., <code>[0.2, 0.2, -0.2, -0.2]</code> will sound higher than <code>[0.2, 0.2, 0.2, -0.2, -0.2, -0.2]</code>). (This is a really simplified explanation of things).</p>
  <p>50 positive samples followed by 50 negative samples will produce the same pitch as middle A on a piano (when the sample rate in 44,100Hz). Let's use that and generate our sample array:</p>
  <pre><code>AMPLITUDE = 0.3
one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)</code></pre>
  <p>Next, let's wrap the samples in a <code>Buffer</code>:</p>
  <pre><code>buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))</code></pre>
  <p>Notice that we used the <code>Format</code> class to identify the sample format. The <code>Format</code> constructor takes 3 arguments: the number of channels, the format of each sample, and the sample rate. You're on the honor system to use the correct format here, weird stuff could happen if you use the wrong format.</p>
  <p>Now let's write the buffer to a file called "<code>square.wav</code>" in the current working directory:</p>
  <pre><code>Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  writer.write(buffer)
end</code></pre>
  <p>Notice that we gave the <code>Writer</code> a <code>Format</code> as well. This tells <code>Writer</code> what format to write any samples in. Also notice that the sample format (<code>:pcm_16</code>) is different from the <code>Buffer</code> we created - things will be translated behind the scenes.</p>
  <p>All of the code to write the samples is done inside a block. When the block exits the file will automatically be closed, so we don't have to do that here. If you want more manually control over when the file is closed you can do that as well by not passing a block and manually calling <code>close()</code>.</p>
  <p>Here's the full program so far:</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

AMPLITUDE = 0.3
one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)

buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))

Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  writer.write(buffer)
end</code></pre>
  <p>When you run this program it should create a file called "<code>square.wav</code>" in the current working directory. If you play this file (for example on a Mac using <code>afplay square.wav</code> from the command line) it should sound like this:</p>
  <audio controls>
    <source src="square_too_short.wav" type="audio/wav">
  </audio>
  <p>...which... doesn't sound like anything! The reason is that we didn't generate enough samples. At the sample rate we're using, 44,100Hz, you'll need 44,100 samples for 1 second of sound. We only generated 100 samples, or about 1/441th of a second. No problem, we can easily fix this by repeating our cycle more times:</p>
  <pre><code>CYCLE_COUNT = 441   # 441 x 100 samples == 44,100 samples, or 1 second of sound

Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  CYCLE_COUNT.times { writer.write(buffer) }
end</code></pre>
  <p>Now when you re-run the program and play "<code>square.wav</code>" it should sound like this.</p>
  <audio controls>
    <source src="square.wav" type="audio/wav">
  </audio>
  <p>You are well on your way to writing an epic <a href="http://en.wikipedia.org/wiki/Nintendo_Entertainment_System">NES</a> soundtrack!</p>
  <p>Here's the full program:</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

AMPLITUDE = 0.3
CYCLE_COUNT = 441   # 441 x 100 samples == 44,100 samples, or 1 second of sound
one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)

buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))

Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  CYCLE_COUNT.times { writer.write(buffer) }
end</code></pre>
</div>
<div class="section bg-white">
  <h2>Reading a Wave File</h2>
  <p>Let's now read the file we just wrote. For that we can use the <code>Reader</code> class.</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

SAMPLE_FRAMES_PER_BUFFER = 4096

Reader.new("square.wav").each_buffer(SAMPLE_FRAMES_PER_BUFFER) do |buffer|
  puts "Buffer number of channels:   #{buffer.channels}"
  puts "Buffer bits per sample:      #{buffer.bits_per_sample}"
  puts "Number of samples in buffer: #{buffer.samples.length}"
  puts "First 10 samples in buffer:  #{buffer.samples[0...10].inspect}"
  puts "--------------------------------------------------------------"
end</code></pre>
  <p>After constructing the <code>Reader </code> we call the <code>each_buffer</code> method. This method is useful when you want to read an entire file. It reads successive buffers of the given size, and passes each to the given block. When all buffers have been read, the file is automatically closed. (You can also manually control what to read and when to close the file, see the <a href="examples.html">examples</a> page for more info.</p>
  <p>When you run the program, it should print out repeated output similar to the following:</p>
  <pre><code>Buffer number of channels:   1
Buffer bits per sample:      16
Number of samples in buffer: 4096
First 10 samples in buffer:  [9830, 9830, 9830, 9830, 9830, 9830, 9830, 9830, 9830, 9830]</code></pre>
  <p>Notice how these samples are integers, rather than the floats that we generated in the last section. This is because when we saved that file, we write the samples as 16-bit PCM samples instead of floating point.</p>
  <p>Also notice that we only read 4,096 samples at a time, instead of trying to the read the whole file. It's a generally a good idea to reading a larger number of smaller buffers, rather than one giant buffer.</p>
  <p>OK, well that's cool, but let's say we want to read this file so we can do some transformation on it, and it will be easier for us if the samples are in floating point format, and are stereo (since we want to combine it will some other files that are stereo). No problem, when constructing the <code>Reader</code> we just need to pass a <code>Format</code> instance that describes how we want to samples to be read as (regardless of the actual underlaying format in the file).</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

SAMPLE_FRAMES_PER_BUFFER = 4096

reader = Reader.new("square.wav", Format.new(:stereo, :float, 44100))
reader.each_buffer(SAMPLE_FRAMES_PER_BUFFER) do |buffer|
  puts "Buffer number of channels:   #{buffer.channels}"
  puts "Buffer bits per sample:      #{buffer.bits_per_sample}"
  puts "Number of samples in buffer: #{buffer.samples.length}"
  puts "First 10 samples in buffer:  #{buffer.samples[0...10].inspect}"
  puts "--------------------------------------------------------------"
end</code></pre>
  <p>Now when you run this program, the output should look like this:</p>
  <pre><code>Buffer number of channels:   2
Buffer bits per sample:      32
Number of samples in buffer: 4096
First 10 samples in buffer:  [[0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875]]</code></pre>
</div>
<div class="section">
  <h2>Next Steps</h2>
  <p>Head over to the <a href="documentation.html">Documentation</a> page where you can see more <a href="examples.html">code examples</a>, read full <a href="doc/index.html">API documentation</a>, and get the low down on <a href="how_wave_files_work.html">how the Wave file format works</a> behind the scenes.</p>
</div>
<div class="footer">
  <p>View the source on <a href="https://github.com/jstrait/wavefile/">GitHub</a>.</p>
  <p>Copyright &copy; <a href="http://www.joelstrait.com">Joel Strait</a> 2009-13.</p>
</div>
</body>
</html>
