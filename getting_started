<!DOCTYPE html>
<html lang="en">
<head>
  <title>WaveFile Gem</title>
  <meta charset="utf-8">
  <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Playfair+Display:400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Mono">
  <link rel="stylesheet" type="text/css" href="wavefile.css">
</head>
<body>
<div id="header">
  <h1><a href="http://wavefilegem.com/">WaveFile Gem</a></h1>
  <ul id="navigation">
    <li><a href="examples.html">Examples</a></li>
    <li><a href="documentation.html">Documentation</a></li>
    <li><a href="how_wave_files_work.html">How Wave Files Work</a></li>
  </ul>
</div>
<div class="section">
  <h2>First Steps</h2>
  <p>First, <a href="http://wavefilegem.com#installation">install the WaveFile gem</a>.</p>
  <p>Next, if you're just getting started with audio programming, you might want to read up on some of the basics of digital audio first. Check out <a href="http://www.joelstrait.com/blog/2009/10/12/a_digital_audio_primer">this blog post</a> for an introduction.</p></p>
</div>
<div class="section bg-white">
  <h2>Basic Concepts</h2>
  <p>The WaveFile gem lets you both read and write wave files. Reading is done using the <code>Reader</code> class, and writing is done using the <code>Writer</code> class.</p>
  <p>The <code>Buffer</code> class represents a collection of samples in a given sample format (e.g. stereo 16-bit PCM samples at a 44,100Hz sample rate). When samples are read using <code>Reader</code> they are returned in <code>Buffer</code> instances. Samples to be written are given to <code>Writer</code> wrapped in <code>Buffer</code> instances as well.</p>
  <p>A <code>Buffer</code> consists of two parts: a Ruby array of samples, and a <code>Format</code> instance that describes what sample format. For example, the sample array in a <code>Buffer</code> read out of a mono 8-bit PCM file (in which each sample is an integer between 0 and 255) might look like this:</p>
  <pre><code>[45, 192, 13, 231, 201, 101, 15, ...etc...]</code></pre>
  <p>When there is more than one channel, each sample frame will be represent by a sub array. For example, a set of stereo floating point samples (in which each sample is between -1.0 and 1.0) might look like this:</p>
  <pre><code>[[-0.2, 0.4], [0.3, 0.9], [-0.4, -0.8], [0.9, -0.2], [-0.3, 0.4], ...etc...]</code></pre>
  <p>If writing a program that creates sound, you would generate an array like this with the sample data, then wrap it in a <code>Buffer</code>, and then use <code>Writer</code> to write the samples in the <code>Buffer</code> to disk.</p>
  <p><code>Buffer</code>s have the ability to convert their samples to a different format. This means that you can read samples from a file in a different format than what is actually in the file (e.g. read a file with 8-bit samples and get 16-bit samples back). You can also do the same with <code>Writer</code> - for example, generate floating point samples between -1.0 and 1.0, and transparently write them to a file as PCM samples.</p>
</div>
<div class="section">
  <h2>Creating a New Wave File</h2>
  <p>Let's write a simple tone to a wave file. A <a href="">square wave</a> is about the simplest way to create a sound, so let's do that. A square wave consists a some repeated samples, followed by the same number of repeated samples at the opposite amplitude. For example:</p>
  <pre><code>[0.3, 0.3, 0.3, 0.3, -0.3, -0.3, -0.3, -0.3,  ...and repeated...]</code></pre>
  <p>So, we'll write some code to generate these samples, and then wrap them in a <code>Buffer</code>, and then write these buffers to a file using <code>Writer</code>.</p>
  <p>The samples we'll generate will be in float format, which means they should be between -1.0 and 1.0. The larger each sample value, the louder it will sound (i.e. 0.5 will sound louder than 0.3). The faster that we alternate between the positive and negative samples, the higher the frequency of the tone (i.e., <code>[0.2, 0.2, -0.2, -0.2]</code> will sound higher than <code>[0.2, 0.2, 0.2, -0.2, -0.2, -0.2]</code>). (This is a really simplified explanation of things).</p>
  <p>50 positive samples followed by 50 negative samples will produce the same pitch as middle A on a piano (when the sample rate in 44,100Hz). Let's use that and generate our sample array:</p>
  <pre><code>
  AMPLITUDE = 0.3
  one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)
  </code></pre>
  <p>Next, let's wrap the samples in a <code>Buffer</code>:</p>
  <pre><code>
  buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))
  </code></pre>
  <p>Notice that we used the <code>Format</code> class to identify the sample format. The <code>Format</code> constructor takes 3 arguments: the number of channels, the format of each sample, and the sample rate. You're on the honor system to use the correct format here, weird stuff could happen if you use the wrong format.</p>
  <p>Now let's write the buffer to a file called "<code>square.wav</code>" in the current working directory:</p>
  <pre><code>
  Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
    writer.write(buffer)
  end
  </code></pre>
  <p>Notice that we gave the <code>Writer</code> a <code>Format</code> as well. This tells <code>Writer</code> what format to write any samples in. Also notice that the sample format (<code>:pcm_16</code>) is different from the <code>Buffer</code> we created - things will be translated behind the scenes.</p>
  <p>All of the code to write the samples is done inside a block. When the block exits the file will automatically be closed, so we don't have to do that here. If you want more manually control over when the file is closed you can do that as well by not passing a block and manually calling <code>close()</code>.</p>
  <p>Here's the full program so far:</p>
  <pre><code>
  require 'wavefile'
  include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

  AMPLITUDE = 0.3
  one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)

  buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))

  Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
    writer.write(buffer)
  end
  </code></pre>
  <p>When you run this program it should create a file called "<code>square.wav</code>" in the current working directory. If you play this file (for example on a Mac using <code>afplay square.wav</code> from the command line) it should sound like this:</p>
  <p>AUDIO TAG GOES HERE</p>
  <p>...which... doesn't sound like anything! The reason is that we didn't generate enough samples. At the sample rate we're using, 44,100Hz, you'll need 44,100 samples for 1 second of sound. We only generated 100 samples, or about 1/441th of a second. No problem, we can easily fix this by repeating our cycle more times:</p>
  <pre><code>
  CYCLE_COUNT = 441   # 441 x 100 samples == 44,100 samples, or 1 second of sound

  Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
    CYCLE_COUNT.times { writer.write(buffer) }
  end
  </code></pre>
  <p>Now when you re-run the program and play "<code>square.wav</code>" it should sound like this.</p>
  <p>AUDIO TAG GOES HERE</p>
  <p>You are well on your way to writing an epic <a href="">NES</a> soundtrack!</p>
  <p>Here's the full program:</p>
  <pre><code>
  require 'wavefile'
  include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

  AMPLITUDE = 0.3
  CYCLE_COUNT = 441   # 441 x 100 samples == 44,100 samples, or 1 second of sound
  one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)

  buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))

  Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
    CYCLE_COUNT.times { writer.write(buffer) }
  end
  </code></pre>
</div>
<div class="footer">
  <p>View the source on <a href="https://github.com/jstrait/wavefile/">GitHub</a>.</p>
  <p>Copyright &copy; <a href="http://www.joelstrait.com">Joel Strait</a> 2009-13.</p>
</div>
</body>
</html>
